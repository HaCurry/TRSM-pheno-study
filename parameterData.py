# -*- coding: utf-8 -*-
import csv
import pandas
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import scipy.interpolate
from scipy.interpolate import CubicSpline
mpl.rcParams.update(mpl.rcParamsDefault)
from numpy import ma
from subprocess import call
import subprocess
import configparser

def paramDirCreator(userParametersDict):

#    create directory for storage
    dataId = 'mS' + str(userParametersDict['ms']) + '-' + 'mX' + str(userParametersDict['mx'])
    subprocess.run(['mkdir', dataId])
    
    return dataId



def repackingProgramParamDict(userParametersDict):

#    parameter values used by script
    programParametersDict = {
        'mHa_lb': 80, 'mHa_ub': 80, 'mHb_lb': 125.09, 'mHb_ub': 125.09, 'mHc_lb': 375, 'mHc_ub': 375,
        'ths_lb': 1.352, 'ths_ub': 1.352, 'thx_lb': 1.175, 'thx_ub': 1.175, 'tsx_lb': -0.407, 'tsx_ub': -0.407,
        'vs_lb': 120, 'vs_ub': 120, 'vx_lb': 890, 'vx_ub': 890,
        }
    
    # change parameters used in script to user given masses
    programParametersDict['mHa_lb'] = userParametersDict['ms']
    programParametersDict['mHa_ub'] = userParametersDict['ms']

    programParametersDict['mHc_lb'] = userParametersDict['mx']
    programParametersDict['mHc_ub'] = userParametersDict['mx']

    userParametersKeys = userParametersDict.keys()

#        additional parameters given by user inserted in programParametersDict
    for key in userParametersKeys:
        if key == 'ms' or key == 'mx':
            continue
        else:
            programParametersDict[key] = userParametersDict[key]

    return programParametersDict



def param(programParametersDict, dataId, paramFree, points, **kwargs):

    ########################    kwargs    ########################

#    default option is 100. Number of points generated by param
    if 'points' in kwargs:
            points = kwargs['points']

    else:
        points = 100

    if 'CreateDir' in kwargs:
        CreateDir = kwargs['CreateDir']

#    default option set to True. Creates parameter specific directory inside
#    directory dataId, created by other functions.
    else:
        createDir = True
    
    if createDir == True:
        paramDir = dataId + '/' + paramFree + '_' + dataId
        subprocess.run(['mkdir', paramDir])

#    otherwise create a directory paramDir in local directory
    else:
        print('No directory found, output in local directory.')
        paramDir = paramFree + '_' + dataId
        subprocess.run(['mkdir', paramDir])

#    default option set to True. Prints shorter outputs from ScannerS in shell
    if 'shortLog' in kwargs:
        shortLog = kwargs['shortLog']
    
    else:
        shortLog = True

    ##############################################################


    config = configparser.ConfigParser()

    config['DEFAULT'] = {'bfb': 'apply',
                         'uni': 'apply',
                         'stu': 'apply',
                         'Higgs': 'apply'}
    config['scan'] = {'mHa': str(programParametersDict['mHa_lb']) + ' ' + str(programParametersDict['mHa_ub']),
                      'mHb': str(programParametersDict['mHb_lb']) + ' ' + str(programParametersDict['mHb_ub']),
                      'mHc': str(programParametersDict['mHc_lb']) + ' ' + str(programParametersDict['mHc_ub']),
                      
                      't1':  str(programParametersDict['ths_lb']) + ' ' + str(programParametersDict['ths_ub']),
                      't2':  str(programParametersDict['thx_lb']) + ' ' + str(programParametersDict['thx_ub']),
                      't3':  str(programParametersDict['tsx_lb']) + ' ' + str(programParametersDict['tsx_ub'])}

    if paramFree == 'ths':
        config['scan']['t1'] = str(-np.pi/2) + ' ' + str(np.pi/2)
        config['scan']['t2'] = str(programParametersDict['thx_lb']) + ' ' + str(programParametersDict['thx_ub'])
        config['scan']['t3'] = str(programParametersDict['tsx_lb']) + ' ' + str(programParametersDict['tsx_ub'])
        
        config['scan']['vs'] = str(programParametersDict['vs_lb']) + ' ' + str(programParametersDict['vs_ub'])
        config['scan']['vx'] = str(programParametersDict['vx_lb']) + ' ' + str(programParametersDict['vx_ub'])

    elif paramFree == 'thx':
        config['scan']['t1'] = str(programParametersDict['ths_lb']) + ' ' + str(programParametersDict['ths_ub'])
        config['scan']['t2'] = str(-np.pi/2) + ' ' + str(np.pi/2)
        config['scan']['t3'] = str(programParametersDict['tsx_lb']) + ' ' + str(programParametersDict['tsx_ub'])
        
        config['scan']['vs'] = str(programParametersDict['vs_lb']) + ' ' + str(programParametersDict['vs_ub'])
        config['scan']['vx'] = str(programParametersDict['vx_lb']) + ' ' + str(programParametersDict['vx_ub'])

    elif paramFree == 'tsx':
        config['scan']['t1'] = str(programParametersDict['ths_lb']) + ' ' + str(programParametersDict['ths_ub'])
        config['scan']['t2'] = str(programParametersDict['thx_lb']) + ' ' + str(programParametersDict['thx_ub'])
        config['scan']['t3'] = str(-np.pi/2) + ' ' + str(np.pi/2)
        
        config['scan']['vs'] = str(programParametersDict['vs_lb']) + ' ' + str(programParametersDict['vs_ub'])
        config['scan']['vx'] = str(programParametersDict['vx_lb']) + ' ' + str(programParametersDict['vx_ub'])
    
    elif paramFree == 'vs':
        config['scan']['t1'] = str(programParametersDict['ths_lb']) + ' ' + str(programParametersDict['ths_ub'])
        config['scan']['t2'] = str(programParametersDict['thx_lb']) + ' ' + str(programParametersDict['thx_ub'])
        config['scan']['t3'] = str(programParametersDict['tsx_lb']) + ' ' + str(programParametersDict['tsx_ub'])
        
        config['scan']['vs'] = '1 1000'
        config['scan']['vx'] = str(programParametersDict['vx_lb']) + ' ' + str(programParametersDict['vx_ub'])

    elif paramFree == 'vx':
        config['scan']['vs'] = str(programParametersDict['vs_lb']) + ' ' + str(programParametersDict['vs_ub'])
        config['scan']['vx'] = '1 1000'
        
    else:
        raise Exception('No paramFree chosen in function vev')
    
    configDir = paramDir + '/' + 'config_' + paramFree + '_' + dataId + '.ini'
    
    with open(configDir, 'w') as configfile:
        config.write(configfile)
    
    configDir = 'config_' + paramFree + '_' + dataId + '.ini'
    outputDir = 'output_' + paramFree + '_' + dataId + '.tsv'
    
    runTRSM = ['../../../TRSMBroken', outputDir, '--config', configDir, 'scan', '-n', str(points)]
    
    try:
        shell_output = subprocess.run(runTRSM, timeout = 180, capture_output = True, cwd = paramDir)
        shell_output = shell_output.stdout.decode('utf-8')
        shell_output_short = (shell_output.splitlines())[-17:]
        
        if shortLog == True:
            
            for line in shell_output_short:
                print(line)
        
        with open(paramDir + '/' + paramFree + dataId + '_full_log.txt', 'w') as text_file:
            text_file.write(shell_output)
        
        shell_output = shell_output.splitlines()

        with open(paramDir + '/' + paramFree + dataId + '_short_log.txt', 'w') as text_file:
            
            for line in shell_output_short:
                text_file.write(line + '\n')
        
    except subprocess.TimeoutExpired:
        print('Process timed out for taking too long. ')



def parameterMain(listUserParametersDict, **kwargs):
    '''Main function calling everything else'''
    
    print('+---------------+')
    print(' Starting script')
    print('+---------------+')
    
    
    for userParametersDict in listUserParametersDict:
        
#        create directory for storage, returns name of directory
        dataId = paramDirCreator(userParametersDict)

#        reformats user given dictionary to usable format for param
        programParametersDict = repackingProgramParamDict(userParametersDict)

        param(programParametersDict, dataId, 'ths', **kwargs)
        param(programParametersDict, dataId, 'thx', **kwargs)
        param(programParametersDict, dataId, 'tsx', **kwargs)
        
        param(programParametersDict, dataId, 'vs', **kwargs)
        param(programParametersDict, dataId, 'vx', **kwargs)
    
    print('+----------------+')
    print(' Script complete!')
    print('+----------------+')











if __name__ == '__main__':
    
    limits = pandas.read_json('Atlas2023Limits.json')

    mx, ms, limit_obs, limit_exp = [], [], [], []

    for element in limits:
        mx.append((limits[element])[0])
        ms.append((limits[element])[1])
    #    limit_exp.append((limits[element])[2] * 10 **(-3))
    #    limit_obs.append((limits[element])[3] * 10 **(-3))
        limit_exp.append((limits[element])[2] * 10 **(-3))
        limit_obs.append((limits[element])[3] * 10 **(-3))
        # limit_exp.append((limits[element])[2] )
        # limit_obs.append((limits[element])[3] )

    mx = np.array(mx)
    ms = np.array(ms)
    limit_exp = np.array(limit_exp)
    limit_obs = np.array(limit_obs)

    def constrained_observed_lim(ms, mx, limit_obs, ms_lb = 1, ms_ub = 124, mx_lb = 126, mx_ub = 500, LessThanOrEqualTo = True):
        ms_BP2constrained = []
        mx_BP2constrained = []
        limit_obs_BP2constrained = []
        if LessThanOrEqualTo == True:
            for i in range(len(limit_obs)):
                # if (BP2_x_min < ms[i]) and  (ms[i] < BP2_x_max) and (BP2_y_min < mx[i]) and (mx[i] < BP2_y_max):
                # MAKE SURE TO PLOT THIS SO YOU HAVE YOUR DESIRED POINTS BECAUSE THE EQUALITY MIGHT INCLUDE SOME
                # UNDESIRED POINTS IF THE FLOAT VALUE IS VERY CLOSE TO HE BOUNDS. OTHERWISE SET LessThanOrEqualTo = False
                if (ms_lb <= ms[i]) and  (ms[i] <= ms_ub) and (mx_lb <= mx[i]) and (mx[i] <= mx_ub):
                    ms_BP2constrained.append(ms[i])
                    mx_BP2constrained.append(mx[i])
                    limit_obs_BP2constrained.append(limit_obs[i])
                else:
                    continue
            
            return ms_BP2constrained, mx_BP2constrained, limit_obs_BP2constrained
        
        else:
            for i in range(len(limit_obs)):
                # if (BP2_x_min < ms[i]) and  (ms[i] < BP2_x_max) and (BP2_y_min < mx[i]) and (mx[i] < BP2_y_max):
                # MAKE SURE TO PLOT THIS SO YOU HAVE YOUR DESIRED POINTS BECAUSE THE EQUALITY MIGHT INCLUDE SOME
                # UNDESIRED POINTS IF THE FLOAT VALUE IS VERY CLOSE TO HE BOUNDS. OTHERWISE SET LessThanOrEqualTo = False
                if (ms_lb < ms[i]) and  (ms[i] < ms_ub) and (mx_lb < mx[i]) and (mx[i] < mx_ub):
                    ms_BP2constrained.append(ms[i])
                    mx_BP2constrained.append(mx[i])
                    limit_obs_BP2constrained.append(limit_obs[i])
                else:
                    continue
            
            return ms_BP2constrained, mx_BP2constrained, limit_obs_BP2constrained
        
    ms_BP2constrained, mx_BP2constrained, limit_obs_BP2constrained = constrained_observed_lim(ms, mx, limit_obs, LessThanOrEqualTo = True)

    BP2_dictPointlistAtlas = []
    for i in range(len(limit_obs_BP2constrained)):
    #    BP2_dictPointlistAtlas.append({ "ms": ms_BP2constrained[i], "mx": mx_BP2constrained[i], "yaxis": limit_obs_BP2constrained[i]})
        BP2_dictPointlistAtlas.append({ "ms": ms_BP2constrained[i], "mx": mx_BP2constrained[i], "points": 10})
        
    
    parameterMain(BP2_dictPointlistAtlas, points = 10)







